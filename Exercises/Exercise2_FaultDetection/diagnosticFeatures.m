function featureTable = diagnosticFeatures(inputData)
%DIAGNOSTICFEATURES recreates results in Diagnostic Feature Designer.
%
% Input:
%  inputData: A timetable.
%
% Output:
%  featureTable: A table containing all features.
%
% This function computes signals:
%  Vib_acpi_env_interp/Data
%  Vib_acpi_env_tsproc/Data
%
% This function computes features:
%  Vib_acpi_env_tsproc_tsfeat/Minimum
%  Vib_acpi_env_tsproc_tsfeat/IQR
%  Vib_acpi_env_sigstats/Mean
%  Vib_acpi_env_tsfeat/Q3
%  Vib_acpi_env_tsfeat/IQR
%  Ia_env_ps_fault/PeakAmp3
%  Ia_env_ps_fault/PeakAmp4
%
% Organization of the function:
% 1. Compute signals/spectra/features
% 2. Extract computed features into a table
%
% Modify the function to add or remove data processing, feature generation
% or ranking operations.

% Auto-generated by MATLAB on 19-Aug-2024 11:36:50

% Initialize feature table.
featureTable = table;

% Get all input variables.
Vib_acpi_env = table(inputData.Time,inputData.Vib_acpi_env,'VariableNames',{'Time','Data'});
Ia_env_ps = table(inputData.Col1,inputData.Ia_env_ps,'VariableNames',{'Col1','Col2'});

%% Interpolation
% Compute interpolation
time = Vib_acpi_env.Time;

% Get sampling period
Vib_acpi_env_interp_Fs = effectivefs(time);
samplePeriod_numeric = 1/Vib_acpi_env_interp_Fs;
if isduration(time) || isdatetime(time)
    samplePeriod = seconds(samplePeriod_numeric);
else
    samplePeriod = samplePeriod_numeric;
end

timeOrigin = datetime(0,1,1,0,0,0);
if isdatetime(time)
    ivStart = min(time) - timeOrigin;
    ivEnd = max(time) - timeOrigin;
else
    ivStart = min(time);
    ivEnd = max(time);
end

if rem(ivStart, samplePeriod) ~= 0
    gridStartIdx = ceil((ivStart+eps)/samplePeriod);
else
    gridStartIdx = ivStart/samplePeriod;
end

if rem(ivEnd, samplePeriod) ~= 0
    gridEndIdx = floor((ivEnd-eps)/samplePeriod);
else
    gridEndIdx = ivEnd/samplePeriod;
end

ivGrid = (gridStartIdx:gridEndIdx)'*samplePeriod;
if isdatetime(time)
    ivGrid = ivGrid + timeOrigin;
end

% Interpolation
val = interp1(time,Vib_acpi_env.Data,ivGrid,'linear',NaN);
Vib_acpi_env_interp = table(ivGrid,val,'VariableNames',{'Time','Data'});

%% TimeSeriesProcessing
% Apply time series processing steps.
x = Vib_acpi_env.Data;
t = Vib_acpi_env.Time;
% Detrend the signal.
order = 1;
x = detrend(x, order, 'omitnan', 'SamplePoints', t);

% Store computed signal in a table.
Vib_acpi_env_tsproc = table(t,x,'VariableNames',{'Time','Data'});

%% TimeSeriesFeatures
% Compute time series features.
inputSignal = Vib_acpi_env_tsproc.Data;
quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

% Extract individual feature values.
Minimum = min(inputSignal);
IQR = quartiles(3)-quartiles(1);

% Concatenate signal features.
featureValues = [Minimum,IQR];

% Store computed features in a table.
featureNames = {'Minimum','IQR'};
Vib_acpi_env_tsproc_tsfeat = array2table(featureValues,'VariableNames',featureNames);

% Append computed features to featureTable.
newFeatureNames = cell(1, numel(featureNames));
for ct = 1:numel(featureNames)
    newFeatureNames{ct} = ['Vib_acpi_env_tsproc_tsfeat/' featureNames{ct}];
end
Vib_acpi_env_tsproc_tsfeat = renamevars(Vib_acpi_env_tsproc_tsfeat, featureNames, newFeatureNames);
featureTable = [featureTable, Vib_acpi_env_tsproc_tsfeat];

%% SignalFeatures
% Compute signal features.
inputSignal = Vib_acpi_env.Data;
Mean = mean(inputSignal,'omitnan');

% Concatenate signal features.
featureValues = Mean;

% Store computed features in a table.
featureNames = {'Mean'};
Vib_acpi_env_sigstats = array2table(featureValues,'VariableNames',featureNames);

% Append computed features to featureTable.
newFeatureNames = cell(1, numel(featureNames));
for ct = 1:numel(featureNames)
    newFeatureNames{ct} = ['Vib_acpi_env_sigstats/' featureNames{ct}];
end
Vib_acpi_env_sigstats = renamevars(Vib_acpi_env_sigstats, featureNames, newFeatureNames);
featureTable = [featureTable, Vib_acpi_env_sigstats];

%% TimeSeriesFeatures
% Compute time series features.
inputSignal = Vib_acpi_env.Data;
quartiles = quantile(inputSignal, [0.25 0.5 0.75]);

% Extract individual feature values.
Q3 = quartiles(3);
IQR = quartiles(3)-quartiles(1);

% Concatenate signal features.
featureValues = [Q3,IQR];

% Store computed features in a table.
featureNames = {'Q3','IQR'};
Vib_acpi_env_tsfeat = array2table(featureValues,'VariableNames',featureNames);

% Append computed features to featureTable.
newFeatureNames = cell(1, numel(featureNames));
for ct = 1:numel(featureNames)
    newFeatureNames{ct} = ['Vib_acpi_env_tsfeat/' featureNames{ct}];
end
Vib_acpi_env_tsfeat = renamevars(Vib_acpi_env_tsfeat, featureNames, newFeatureNames);
featureTable = [featureTable, Vib_acpi_env_tsfeat];

%% CustomFaultsFeatures
% Compute the fault frequency bands.
[FB, info] = faultBands(60, [1 2 3 4 5 6], 30, [0 1], 'Width', 10, 'Folding', true);

% Compute spectral fault band metrics.
sd = Ia_env_ps.Col2;
w = Ia_env_ps.Col1;

metrics = faultBandMetrics(sd, w, FB(1:18,:));

% Extract computed features.
metricsNames = {'PeakAmplitude3','PeakAmplitude4'};
featureNames = {'PeakAmp3','PeakAmp4'};
Ia_env_ps_fault = metrics(:,metricsNames);
Ia_env_ps_fault = renamevars(Ia_env_ps_fault, metricsNames, featureNames);

% Append computed features to featureTable.
newFeatureNames = cell(1, numel(featureNames));
for ct = 1:numel(featureNames)
    newFeatureNames{ct} = ['Ia_env_ps_fault/' featureNames{ct}];
end
Ia_env_ps_fault = renamevars(Ia_env_ps_fault, featureNames, newFeatureNames);
featureTable = [featureTable, Ia_env_ps_fault];

end
